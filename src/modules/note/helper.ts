const axios = require("axios");
const ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
import { noteCollection, noteSchema } from "./model";
const { getCollection } = require("../../lib/dbutils");
import { nextval, resetval } from "../sequence/service";
import * as NoteTagHelper from "./tag/helper";
import * as NotelinkHelper from "../notelink/helper";
import * as MetadataDefinitionHelper from "../metadata/definition/helper";
import * as FilterGroupHelper from "../filter-group/helper";
import * as NotelinkAutoHelper from "../notelink/auto/helper";
import { isEmptyOrSpaces } from "../../lib/Utils";

const AI_API = process.env.AI_API || "http://localhost:5003/api";

export const updateNote = async (space: string, reload: string, data: any, userId?: string) => {
  const model = getCollection(space, noteCollection, noteSchema);
  let response = null;
  const contentText = data.content.replace(/<[^>]*>/g, '');
  if (data._id) {
    response = await model.findByIdAndUpdate(
      data._id,
      {
        ...data,
        autoGeneratedSummary: isEmptyOrSpaces(data.summary) ? contentText.substring(0, 250) : '',
        contentText
      },
      { new: true, upsert: true }
    );
  } else {
    response = await model.create({
      ...data,
      autoGeneratedSummary: isEmptyOrSpaces(data.summary) ? contentText.substring(0, 250) : '',
      reference: await nextval("noteId", undefined, space),
      contentText
    });
  }

  let retrain = false;

  if (reload) {
    const updateCount = await nextval('note_update_count', 'ai', space);
    console.log(updateCount);
    if (updateCount <= 20) {
      retrain = true;
    }
    if (updateCount > 20 && updateCount <= 100 && updateCount % 10 === 0) {
      retrain = true;
    }
    if (updateCount > 100 && updateCount <= 500 && updateCount % 25 === 0) {
      retrain = true;
    }
    if (updateCount > 500 && updateCount <= 1000 && updateCount % 50 === 0) {
      retrain = true;
    }
    if (updateCount > 1000 && updateCount % 100 === 0) {
      retrain = true;
    }

    if (updateCount % 200 === 0) {
      const notesCount = await model.find().estimatedDocumentCount();
      await resetval(notesCount + 2, 'note_update_count', 'ai', space);
    }
  }

  if (retrain) {
    await _ai_train(space);
  }

  await _ai_populate_for_note(space, response.reference);

  const notelinks = await NotelinkAutoHelper.getNotelinkAutoByNoteRef(space, response.reference);
  const noteResponse = await model.find({ reference: response.reference });
  let note = null;
  if (noteResponse.length > 0) {
    note = noteResponse[0]
  }

  return {
    notelinks,
    note
  }
};

export const getNote = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find();
  return res.map((item: any) => {
    return {
      ...item,
      summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
    };
  });
};

export const getNoteDictionary = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.find();
  // const res = await _enrichWithGroupColor(space, await model.find());
  // return res.map((item: any) => {
  //   return {
  //     _id: item._id,
  //     name: item.name,
  //     reference: item.reference,
  //     summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
  //     color: item.color
  //   };
  // });
};

const _enrichWithGroupColor = async (space: string, data: any[]) => {
  const filterGroupList = await FilterGroupHelper.getFilterGroup(space);
  return data.map((item: any) => {
    let out = { ...item._doc };
    filterGroupList
      .filter(
        (item: any) =>
          !isEmptyOrSpaces(item.criteria) && !isEmptyOrSpaces(item.color)
      )
      .forEach((filter: any) => {
        // const { file, path, tag, general } = getFilterKeys(filter.criteria);
        // if (_processFilterPerRecord(item, file, tag, path, general)) {
        out.color = filter.color;
        // }
      });
    return out;
  });
};

const _processFilterPerRecord = (
  record: any,
  file: string[],
  tag: string[],
  path: string[][],
  general: string[]
) => {
  const _recordName = record.name.toLowerCase();
  if (!file.every((item: string) => _recordName.includes(item))) {
    return null;
  }

  const _recordContent = record.content.toLowerCase();
  if (!tag.every((item: string) => _recordContent.includes(item))) {
    return null;
  }

  if (!general.every((item: string) => _recordContent.includes(item))) {
    return null;
  }

  return record;
};

export const getRecentlyCreatedNote = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find().sort({ $natural: -1 }).limit(1);
  if (res.length === 0) {
    return null;
  }
  return res[0];
};

export const getNoteByReference = async (space: string, reference: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({ reference });
  if (res.length === 0) {
    return null;
  }
  return res[0];
};

export const getNoteById = async (space: string, _id: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({ _id });
  if (res.length > 0) {
    return res[0];
  }
};

export const deleteNotesByFolderIdList = async (
  space: string,
  folderIdList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.remove({ folderId: { $in: folderIdList } });
};

export const getNotesByFolderIdList = async (
  space: string,
  folderIdList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.find({ folderId: { $in: folderIdList } });
};

export const getNotesByReferenceList = async (
  space: string,
  refList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.find({ reference: { $in: refList } });
};

export const deleteNote = async (space: string, _id: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  await model.remove({ _id });
  return { note: _id };
};

export const deleteNoteByReference = async (space: string, reference: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  await model.remove({ reference });
  await NotelinkHelper.deleteNotelinkByReference(space, reference);
  await NotelinkAutoHelper.deleteNotelinkByReference(space, reference);
  return { note: reference };
};

export const searchNoteByText = async (space: string, text: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({
    $text: { $search: `\"${text}\"`, $caseSensitive: false },
  });
  return res;
};

export const searchNote = async (space: string, text: string, searchPref: any) => {
  const _text = text.toLowerCase().replace(/ +/g, ' ');
  const model = getCollection(space, noteCollection, noteSchema);
  const condition = await _getSearchCondition(space, _text, searchPref);
  const res = await model.find({ $or: condition }).sort({ createdAt: -1 });
  return res.map((item: any) => {
    return {
      ...item._doc,
      summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
    };
  });
};

const _getSearchCondition = async (space: string, text: string, searchPref: any) => {
  const metadataDefinitionList = await MetadataDefinitionHelper.getMetadataDefinition(space);
  const searchFields: string[] = [];

  if (searchPref) {
    Object.keys(searchPref).forEach(fieldName => {
      if (searchPref[fieldName]) {
        searchFields.push(fieldName);
      }
    });
  }

  const condition: any[] = [];
  if (searchFields.length === 0 || searchFields.includes('content')) {
    // condition.push({
    //   $text: { $search: new RegExp(text, 'i'), $caseSensitive: false },
    // });
    condition.push({
      content: new RegExp(text, 'i')
    })
  }
  if (searchFields.includes('name')) {
    condition.push({
      name: new RegExp(text, 'i')
    })
  }
  if (searchFields.includes('labels')) {
    condition.push({
      labels: {
        $in: text.split(" ")
      }
    })
  }
  metadataDefinitionList.forEach((item: any) => {
    if (searchFields.includes(item._id.toString())) {
      condition.push({
        [item._id.toString()]: new RegExp(text, 'i')
      })
    }
  })
  return condition;
}

const _ai_train = async (space: string) => {
  try {
    await axios.get(`${AI_API}/similarity/${space}/train`, {});
    console.log("--model retrained");
  } catch (err) {
    console.log(err);
  }
}

const _ai_populate = async (space: string) => {
  try {
    await axios.get(`${AI_API}/similarity/${space}/populate`, {});
  } catch (err) {
    console.log(err);
  }
}

const _ai_populate_for_note = async (space: string, reference: string) => {
  try {
    await axios.get(`${AI_API}/similarity/${space}/populate/${reference}`, {});
  } catch (err) {
    console.log(err);
  }
}
