const axios = require("axios");
const ONEAUTH_API = process.env.ONEAUTH_API || "http://localhost:4010/api";
import { noteCollection, noteSchema } from "./model";
const { getCollection } = require("../../lib/dbutils");
import { nextval } from "../sequence/service";
import * as NoteTagHelper from "./tag/helper";
import * as NotelinkHelper from "../notelink/helper";
import * as MetadataDefinitionHelper from "../metadata/definition/helper";
import * as FilterGroupHelper from "../filter-group/helper";
import { isEmptyOrSpaces } from "../../lib/Utils";

export const updateNote = async (space: string, data: any, userId?: string) => {
  const model = getCollection(space, noteCollection, noteSchema);
  let response = null;
  const contentText = data.content.replace(/<[^>]*>/g, '');
  if (data._id) {
    response = await model.findByIdAndUpdate(
      data._id,
      {
        ...data,
        autoGeneratedSummary: isEmptyOrSpaces(data.summary) ? contentText.substring(0, 250) : '',
        contentText
      },
      { new: true, upsert: true }
    );
  } else {
    response = await model.create({
      ...data,
      autoGeneratedSummary: isEmptyOrSpaces(data.summary) ? contentText.substring(0, 250) : '',
      reference: await nextval("noteId", undefined, space),
      contentText
    });
  }

  if (response) {
    await _populateTags(space, response);
    await _populateLinks(space, response);
  }

  return response;
};

const _populateTags = async (space: string, note: any) => {
  const noteRef = note.reference;
  const labels = note.labels;

  await NoteTagHelper.deleteByNoteRef(space, noteRef);
  if (labels && labels.length > 0) {
    await NoteTagHelper.addTagsForNoteRef(space, noteRef, labels);
  }
};

const _populateLinks = async (space: string, note: any) => {
  const noteRef = note.reference;
  const content = note.content;

  await NotelinkHelper.deleteBySourceNoteRef(space, noteRef);

  let linkedNoteRefList = content.match(/\[\[(\w+)\]\]/g);

  if (!linkedNoteRefList) {
    return;
  }
  linkedNoteRefList = linkedNoteRefList.map((item: string) =>
    item.replace("[[", "").replace("]]", "")
  );

  if (linkedNoteRefList && linkedNoteRefList.length > 0) {
    await NotelinkHelper.addLinksForSourceNoteRef(
      space,
      noteRef,
      linkedNoteRefList
    );
  }
};

export const getNote = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find();
  return res.map((item: any) => {
    return {
      ...item,
      summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
    };
  });
};

export const getNoteDictionary = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find();
  return res.map((item: any) => {
    return {
      _id: item._id,
      name: item.name,
      folderId: item.folderId,
      reference: item.reference,
      summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
    };
  });
};

export const getRecentlyCreatedNote = async (space: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find().sort({$natural:-1}).limit(1);
  if (res.length === 0) {
    return null;
  }
  return res[0];
};

export const getNoteByReference = async (space: string, reference: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({ reference });
  if (res.length === 0) {
    return null;
  }
  return res[0];
};

export const getNoteById = async (space: string, _id: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({ _id });
  if (res.length > 0) {
    return res[0];
  }
};

export const deleteNotesByFolderIdList = async (
  space: string,
  folderIdList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.remove({ folderId: { $in: folderIdList } });
};

export const getNotesByFolderIdList = async (
  space: string,
  folderIdList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.find({ folderId: { $in: folderIdList } });
};

export const getNotesByReferenceList = async (
  space: string,
  refList: string[]
) => {
  const model = getCollection(space, noteCollection, noteSchema);

  return await model.find({ reference: { $in: refList } });
};

export const deleteNote = async (space: string, _id: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  await model.remove({ _id });
  return { note: [_id] };
};

export const searchNoteByText = async (space: string, text: string) => {
  const model = getCollection(space, noteCollection, noteSchema);

  const res = await model.find({
    $text: { $search: `\"${text}\"`, $caseSensitive: false },
  });
  return res;
};

export const searchNote = async (space: string, text: string, searchPref: any) => {
  const _text = text.toLowerCase().replace(/ +/g, ' ');
  const model = getCollection(space, noteCollection, noteSchema);
  const condition = await _getSearchCondition(space, _text, searchPref);
  const res = await model.find({ $or: condition }).sort({ createdAt: -1 });
  return res.map((item: any) => {
    return {
      ...item._doc,
      summary: isEmptyOrSpaces(item.summary) ? item.autoGeneratedSummary : item.summary,
    };
  });
};

const _getSearchCondition = async (space: string, text: string, searchPref: any) => {
  const metadataDefinitionList = await MetadataDefinitionHelper.getMetadataDefinition(space);
  const searchFields: string[] = [];

  if (searchPref) {
    Object.keys(searchPref).forEach(fieldName => {
      if (searchPref[fieldName]) {
        searchFields.push(fieldName);
      }
    });
  }

  const condition: any[] = [];
  if (searchFields.length === 0 || searchFields.includes('content')) {
    // condition.push({
    //   $text: { $search: new RegExp(text, 'i'), $caseSensitive: false },
    // });
    condition.push({
      content: new RegExp(text, 'i')
    })
  }
  if (searchFields.includes('name')) {
    condition.push({
      name: new RegExp(text, 'i')
    })
  }
  if (searchFields.includes('labels')) {
    condition.push({
      labels: {
        $in: text.split(" ")
      }
    })
  }
  metadataDefinitionList.forEach((item: any) => {
    if (searchFields.includes(item._id.toString())) {
      condition.push({
        [item._id.toString()]: new RegExp(text, 'i')
      })
    }
  })
  return condition;
}
